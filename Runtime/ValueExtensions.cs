/* Original code[1] Copyright (c) 2022 Shane Celis[2]
   Licensed under the MIT License[3]

   This comment generated by code-cite[3].

   [1]: https://github.com/shanecelis/SeawispHunter.RolePlay.Attributes
   [2]: https://twitter.com/shanecelis
   [3]: https://opensource.org/licenses/MIT
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.ComponentModel;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace SeawispHunter.RolePlay.Attributes {

public enum InterruptMode {
  Cancel,
  Serial,
  Parallel,
  Ignore,
}

public static class ValueExtensions {
  /** Give ourselves a little projection, as a treat. */
  public static IReadOnlyValue<T> Select<S,T>(this IReadOnlyValue<S> v, Func<S,T> func) {
    var w = ReadOnlyValue.Create(() => func(v.value), out var callOnChange);
    v.PropertyChanged += (_, _) => callOnChange();
    return w;
  }

  public static IReadOnlyValue<U> Zip<S,T,U>(this IReadOnlyValue<S> v, IReadOnlyValue<T> w, Func<S,T,U> func) {
    var u = ReadOnlyValue.Create(() => func(v.value, w.value), out var callOnChange);
    v.PropertyChanged += (_, _) => callOnChange();
    w.PropertyChanged += (_, _) => callOnChange();
    return u;
  }

  /* I don't know. This seems overly complicated. It's no longer projection, it's projection and an inverse/coalesce action. */
  public static IValue<T> Select<S,T>(this IValue<S> v, Func<S,T> @get, Action<IValue<S>,T> @set) {
    var w = Value.Create(() => @get(v.value), x => @set(v, x), out var callOnChange);
    v.PropertyChanged += (_, _) => callOnChange();
    return w;
  }

  internal class ActionDisposable : IDisposable {
    private Action action;
    public ActionDisposable(Action action) => this.action = action;
    public void Dispose() {
      action();
    }
  }

  /** Convenience method to connect to the property change events. */
  public static IDisposable OnChange<T>(this T v, Action<T> action) where T : INotifyPropertyChanged {
    v.PropertyChanged += PropertyChange;
    return new ActionDisposable(() => v.PropertyChanged -= PropertyChange);

    void PropertyChange(object source, PropertyChangedEventArgs args) => action(v);
  }

  public static IModifier<Y> Cast<X,Y>(this IModifier<X> m)
#if NET6_0_OR_GREATER
    where X : INumber<X> where Y : INumber<Y>
#endif
  {
    return new Modifier.CastingModifier<X,Y>(m);
  }

#if UNITY_5_3_OR_NEWER
  public static IEnumerator LerpTo<T>(this IValue<T> v,
                                      Func<T,T,float,T> lerp,
                                      T targetValue,
                                      float duration,
                                      float? period = null,
                                      CancellationToken token = default) {
    T startValue = v.value;
    float start = UnityEngine.Time.time;
    float t = 0f;
    var wait = period.HasValue
      ? new UnityEngine.WaitForSeconds(period.Value)
      : null;
    do {
      t = (UnityEngine.Time.time - start) / duration;
      v.value = lerp(startValue, targetValue, t);
      yield return wait;
    } while (t <= 1f && ! token.IsCancellationRequested);
    if (! token.IsCancellationRequested)
      // v.value = targetValue;
      v.value = lerp(startValue, targetValue, 1f);
  }

  /** Return the prior value and the new value whenever `v` changes. */
  public static IReadOnlyValue<(T,T)> Delta<T>(this IReadOnlyValue<T> v) {
    var lastValue = v.value;
    var w = new Value<(T,T)>((default(T), lastValue));
    v.PropertyChanged += OnChange;
    return w;

    void OnChange(object sender, PropertyChangedEventArgs args) {
      w.value = (lastValue, v.value);
      lastValue = v.value;
    }
  }

  public class CancelableValue<T> : Value<T>, ICancelableValue<T> {
    Action cancel;
    public CancelableValue(T v, Action cancel) : base(v) {
      this.cancel = cancel;
    }

    public void Cancel() {
      cancel();
    }
  }


  /** When value v changes, the returned value will update over time. Good for
      displaying changing values. */
  public static ICancelableValue<T> LerpOnChange<T>(this IReadOnlyValue<T> v,
                                                    UnityEngine.MonoBehaviour component,
                                                    Func<T,T,float,T> lerp,
                                                    float duration,
                                                    float? period = null,
                                                    InterruptMode mode = default) {
    var source = new CancellationTokenSource();
    var token = source.Token;
    bool isRunning = false;
    Queue<T> queue = new Queue<T>();
    var w = new CancelableValue<T>(v.value, Cancel);
    v.PropertyChanged += OnChange;
    return w;

    void OnChange(object sender, PropertyChangedEventArgs args) {
      if (isRunning) {
        switch (mode) {
          case InterruptMode.Cancel:
            queue.Enqueue(v.value);
            source.Cancel();
            source.Dispose();
            source = new CancellationTokenSource();
            token = source.Token;
            break;
          case InterruptMode.Serial:
            queue.Enqueue(v.value);
            break;
          case InterruptMode.Parallel:
            component.StartCoroutine(w.LerpTo(lerp, v.value, duration, period, token));
            break;
          case InterruptMode.Ignore:
            break;
        }
      } else {
        queue.Enqueue(v.value);
        component.StartCoroutine(LerpAround());
      }
    }

    void Cancel() {
      source.Cancel();
      source.Dispose();
      source = new CancellationTokenSource();
      token = source.Token;
      queue.Clear();
    }

    IEnumerator LerpAround() {
      try {
        isRunning = true;
        while (queue.Count > 0) {
          yield return w.LerpTo(lerp, queue.Dequeue(), duration, period, token);
        }
      } finally {
        isRunning = false;
      }
    }
  }

#endif
}
}
