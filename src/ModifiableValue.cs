/* Original code[1] Copyright (c) 2022 Shane Celis[2]
   Licensed under the MIT License[3]

   This comment generated by code-cite[3].

   [1]: https://github.com/shanecelis/SeawispHunter.RolePlay.Attributes
   [2]: https://twitter.com/shanecelis
   [3]: https://opensource.org/licenses/MIT
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Collections;
using System.Collections.Generic;

namespace SeawispHunter.RolePlay.Attributes {

public static class ModifiableValue {

  /** Collect how a particular modifier changes the value.

      Returns an IEnumerable because one modifier may be added multiple times or
      no times, which an enumerable captures. */
  public static IEnumerable<(T before, T after)> ProbeAffects<T>(this IModifiable<IReadOnlyValue<T>, T> modifiable,
                                                                 IModifier<T> modifier) {
    T before = modifiable.initial.value;
    foreach (var _modifier in modifiable.modifiers) {
      T after = before;
      if (_modifier.enabled)
        after = _modifier.Modify(before);
      if (modifier == _modifier)
        yield return (before, after);
      before = after;
    }
  }

  /** Return the delta a modifier (may be multiple) does. */
#if NET6_0_OR_GREATER
  public static T ProbeDelta<T>(this IModifiable<IReadOnlyValue<T>, T> modifiable,
                                IModifier<T> modifier) where T : INumber<T> {
    // => modifiable.ProbeAffects(modifier).Select(x => x.after - x.before).Sum();
    T accum = T.Zero;
    foreach (T delta in modifiable.ProbeAffects(modifier).Select(x => x.after - x.before))
      accum += delta;
    return accum;
  }
#else
  public static T ProbeDelta<T>(this IModifiable<IReadOnlyValue<T>, T> modifiable,
                                IModifier<T> modifier) {
    var op = Modifier.GetOp<T>();
    T accum = op.zero;
    foreach (var delta in modifiable.ProbeAffects(modifier)
             .Select(x => op.Sum(x.after, op.Negate(x.before))))
      accum = op.Sum(accum, delta);
    return accum;
  }
#endif

  /** Remove all of an item from a collection. Returns the number of items removed. */
  public static int RemoveAll<T>(this ICollection<T> collection, T item) {
    int count = 0;
    while (collection.Remove(item))
      count++;
    return count;
  }
}

#if UNITY_5_3_OR_NEWER
/** In order to make Unity's serialization work properly we need to have a
    concrete type rather than interface as its initial value. */
[Serializable]
public class ModifiableValue<T> : Modifiable<Value<T>, T>, IModifiableValue<T> {

  public ModifiableValue(Value<T> initial) : base(initial) { }
  public ModifiableValue(T initialValue) : base(new Value<T>(initialValue)) { }
  public ModifiableValue() : this(default(T)) { }

  IValue<T> IModifiable<IValue<T>,T>.initial => _initial;
}

[Serializable]
public class ModifiableReadOnlyValue<T> : Modifiable<ReadOnlyValue<T>, T> {

  public ModifiableReadOnlyValue(ReadOnlyValue<T> initial) : base(initial) { }
  public ModifiableReadOnlyValue(T initialValue) : base(new ReadOnlyValue<T>(initialValue)) { }
  public ModifiableReadOnlyValue() : this(default(T)) { }

  IReadOnlyValue<T> IModifiable<IReadOnlyValue<T>,T>.initial => _initial;
}

// Sometimes we still need an IValue though!
public class ModifiableIValue<T> : Modifiable<IValue<T>, T>, IModifiableValue<T> {

  public ModifiableIValue(IValue<T> initial) : base(initial) { }
  public ModifiableIValue(T initialValue) : base(new Value<T>(initialValue)) { }
  public ModifiableIValue() : this(default(T)) { }
}

public class ModifiableIReadOnlyValue<T> : Modifiable<IReadOnlyValue<T>, T> {

  public ModifiableIReadOnlyValue(IReadOnlyValue<T> initial) : base(initial) { }
  public ModifiableIReadOnlyValue(T initialValue) : base(new ReadOnlyValue<T>(initialValue)) { }
  public ModifiableIReadOnlyValue() : this(default(T)) { }
}

#else

[Serializable]
public class ModifiableValue<T> : Modifiable<IValue<T>, T>, IModifiableValue<T> {

  public ModifiableValue(IValue<T> initial) : base(initial) { }
  public ModifiableValue(T initialValue) : base(new Value<T>(initialValue)) { }
  public ModifiableValue() : this(default(T)) { }
}

[Serializable]
public class ModifiableReadOnlyValue<T> : Modifiable<IReadOnlyValue<T>, T> {

  public ModifiableReadOnlyValue(IReadOnlyValue<T> initial) : base(initial) { }
  public ModifiableReadOnlyValue(T initialValue) : base(new ReadOnlyValue<T>(initialValue)) { }
  public ModifiableReadOnlyValue() : this(default(T)) { }
}
#endif

/** This Modifiable's `value` is bounded.

    The same result could be achieved with a modifier that comes last by doing
    something like this:

    ```
    ModifiableValue modifiableValue = ...
    modifiableValue.modifiers.Add(1000, Modifier.Create(x => Math.Clamp(x, 0, 1000)));
    ```

    That's a valid way of achieving this effect. However, it seemed like bounds
    were constraints that shouldn't be cast aside if some one called
    `modifiableValue.modifiers.Clear()`.
 */
[Serializable]
public class BoundedModifiable<S,T> : Modifiable<S,T>, IBounded<T>
  where S : IReadOnlyValue<T>
#if NET6_0_OR_GREATER
  where T : INumber<T>
#endif
{
  private IReadOnlyValue<T> _minValue;
  private IReadOnlyValue<T> _maxValue;
  public T minValue => _minValue.value;
  public T maxValue => _maxValue.value;
  public BoundedModifiable(S initial, IReadOnlyValue<T> minValue, IReadOnlyValue<T> maxValue)
    : base(initial) {
    _minValue = minValue;
    _maxValue = maxValue;
  }

  public BoundedModifiable(S value, T lowerBound, IReadOnlyValue<T> upperBound)
    : this(value, new ReadOnlyValue<T>(lowerBound), upperBound) { }

  public BoundedModifiable(S value, IReadOnlyValue<T> lowerBound, T upperBound)
    : this(value, lowerBound, new ReadOnlyValue<T>(upperBound)) { }

  public BoundedModifiable(S value, T lowerBound, T upperBound)
    : this(value, new ReadOnlyValue<T>(lowerBound), new ReadOnlyValue<T>(upperBound)) { }

  public override T value => BoundedValue<T>.Clamp(base.value, minValue, maxValue);
}

[Serializable]
public class Modifiable<S,T> : IModifiable<S,T> where S : IReadOnlyValue<T> {
  protected ModifiersSortedList _modifiers;
  public IPriorityCollection<IModifier<T>> modifiers => _modifiers;
#if UNITY_5_3_OR_NEWER
  [UnityEngine.SerializeField]
#endif
  protected S _initial;
  public virtual S initial => _initial;
  // XXX: Consider caching?
  public virtual T value {
    get {
      T v = initial.value;
      foreach (var modifier in modifiers)
        if (modifier.enabled)
          v = modifier.Modify(v);
      return v;
    }
  }
  [field: NonSerialized]
  public event PropertyChangedEventHandler PropertyChanged;
  private static PropertyChangedEventArgs modifiersEventArgs
    = new PropertyChangedEventArgs(nameof(modifiers));
  public Modifiable(S initial) {
    _initial = initial;
    // if (_initial is INotifyPropertyChanged notify)
    //   notify.PropertyChanged += Chain;
    _initial.PropertyChanged += Chain;
    _modifiers = new ModifiersSortedList(this);
  }

  protected void Chain(object sender, PropertyChangedEventArgs args)
    => OnChange(nameof(initial));

  internal void OnChangeModifiers() => PropertyChanged?.Invoke(this, modifiersEventArgs);
  internal void OnChange(string name) {
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
  }

  internal void ModifiersChanged(object sender, PropertyChangedEventArgs e) {
    PropertyChanged?.Invoke(this, modifiersEventArgs);
  }

  public override string ToString() => value.ToString();
  public string ToString(bool showModifiers) {
    if (! showModifiers)
      return ToString();
    var builder = new StringBuilder();
    builder.Append(" \"base\" ");
    builder.Append(initial);
    builder.Append(' ');
    foreach (var modifier in modifiers) {
      builder.Append(modifier);
      builder.Append(' ');
    }
    builder.Append("-> ");
    builder.Append(value);
    return builder.ToString();
  }

  /** A sorted list for modifiers. It uses a tuple (int priority, int age)
      because SortedList<K,V> can only store one value per key. We may have many
      modifiers with the same priority (default priority is 0). So modifiers are
      ordered by priority first and age second. Each modifier will have a unique
      age ensuring that the keys will be unique.
   */
  protected class ModifiersSortedList : IPriorityCollection<IModifier<T>>, IComparer<(int priority, int age)> {
    private readonly Modifiable<S,T> parent;
    private readonly SortedList<(int, int), IModifier<T>> modifiers = new SortedList<(int, int), IModifier<T>>();
    private int addCount = 0;
    public ModifiersSortedList(Modifiable<S,T> parent) => this.parent = parent;

    public IEnumerator<IModifier<T>> GetEnumerator() => modifiers.Values.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public void Add(IModifier<T> modifier) => Add(0, modifier);
    public void Add(int priority, IModifier<T> modifier) {
      modifier.PropertyChanged -= parent.ModifiersChanged;
      modifier.PropertyChanged += parent.ModifiersChanged;
      modifiers.Add((priority, ++addCount), modifier);
      parent.OnChangeModifiers();
    }

    public void Clear() {
      foreach (var modifier in modifiers.Values)
        modifier.PropertyChanged -= parent.ModifiersChanged;
      modifiers.Clear();
      parent.OnChangeModifiers();
    }

    public bool Contains(IModifier<T> modifier) => modifiers.ContainsValue(modifier);

    public void CopyTo(IModifier<T>[] array, int arrayIndex) => modifiers.Values.CopyTo(array, arrayIndex);

    public bool Remove(IModifier<T> modifier) {
      int i = modifiers.IndexOfValue(modifier);
      if (i < 0)
        return false;
      modifier.PropertyChanged -= parent.ModifiersChanged;
      modifiers.RemoveAt(i);
      parent.OnChangeModifiers();
      return true;
    }

    public int Count => modifiers.Count;
    public bool IsReadOnly => false;

    public int Compare((int priority, int age) x, (int priority, int age) y) {
      int result = x.priority.CompareTo(y.priority);
      if (result != 0)
        return result;
      return x.age.CompareTo(y.age);
    }
  }
}

}
